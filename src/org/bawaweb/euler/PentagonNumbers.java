/**
 * 
 */
package org.bawaweb.euler;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * @author Navroz
 * 
 * Pentagon numbers
 * ====================
 * Ans. 5482660
	Problem 44
	
	Pentagonal numbers are generated by the formula, P(n)=n(3n−1)/2. 
	The first ten pentagonal numbers are:
	
	1, 5, 12, 22, 35, 51, 70, 92, 117, 145, ...
	
	It can be seen that P(4) + P(7) = 22 + 70 = 92 = P(8). 
	However, their difference, 70 − 22 = 48, is not pentagonal.
	
	Find the pair of pentagonal numbers, 
	P(j) and P(k), for which their sum and difference are pentagonal 
	and D = |P(k) − P(j)| is minimised; 
	
	what is the value of D?

 *
 */
public class PentagonNumbers {
	
	static Map<String,Long> pentaMap = new HashMap<String,Long>();	// min & max
	
	static List<Long> pentaList = new ArrayList<Long>();

	public static void main(String[] args) {
		final long start = 1l;//285l;	//	random choice
		System.out.println("Starting from index "+start+
							" -- Pentagular Number["+start+"] -- "+
							"\n_____________________________\n\n");
		
		boolean found = false;
		long 	index = start+1;
		
		pentaList.add(1l);
		
		while (!found) {
			pentaList = getNextPentagonal(pentaList, index);
			// each array in the list has two elements
			List<Long[]> pentaDuosList = combine(pentaList, 2);
			System.out.println("pentaDuosListSize "+pentaDuosList.size()+" abd pentalast is "+pentaList.get(pentaList.size()-1));
			processPentaDuos(pentaDuosList);
			if (pentaMap.get("Min") != null && pentaMap.get("Max") != null) {
				found = true;
				break;
			}
			index++;
		}
		
		
		final long min = getPentagonalNo(pentaMap.get("Min"));
		final long max = getPentagonalNo(pentaMap.get("Max"));
		
		System.out.println("Indexed at T[" + index + "]");
		System.out.println("P[pentaMap.get(Min)] == " + min);
		System.out.println("P[pentaMap.get(Max)] == "+max);
		System.out.println("PSum = "+(min+max)+" is pentagonal "+checkIsPentagonal(min+max));
		System.out.println("PDiff = "+(max-min)+" is pentagonal "+checkIsPentagonal(max-min));
	}
	
	private static void processPentaDuos(List<Long[]> pentaDuosList) {
		for (Long[] pentaDuo : pentaDuosList) {
			final Long p1 = pentaDuo[0];
			final Long p2 = pentaDuo[1];
			if (checkIsPentagonal(p1 + p2) && checkIsPentagonal(Math.abs(p1 - p2))) {
				if (pentaMap.get("Min") == null) {
					if (p1 > p2) {
						pentaMap.put("Min", p2);
						pentaMap.put("Max", p1);
					} else {
						pentaMap.put("Min", p1);
						pentaMap.put("Max", p2);
					}
				} else {
					long exMin = pentaMap.get("Min");
					long exMax = pentaMap.get("Max");
					if (Math.abs(p1 - p2) < Math.abs(exMax - exMin)) {
						if (p1 > p2) {
							pentaMap.put("Min", p2);
							pentaMap.put("Max", p1);
						} else {
							pentaMap.put("Min", p1);
							pentaMap.put("Max", p2);
						}
					}
				}
			}
		}
	}

	private static List<Long> getNextPentagonal(List<Long> list, long num) {
		list.add(getPentagonalNo(num));
		return list;
	}

	private static long getPentagonalNo(final long n) {
		return (n * ((3 * n) - 1)) / 2;
	}
	
	private static boolean checkIsPentagonal(final long aNum) {
		for(long i = 1l; i <= (long)Math.sqrt(aNum)+1; i++) {
			if( getPentagonalNo(i) == aNum) {
//				System.out.println(aNum+" is P["+i+"]");
//				indexMap.put(P,i);
				return true;
			}
		}
		return false;
	}
	
	public static List<Long[]> combine(final List<Long> arr, final int k) {
		if (arr == null)
			return null;
		if (arr.size() == 0 || arr.size() < k || k <= 0)
			return null;

		long[] data = new long[k];

		List<Long[]> combos = new ArrayList<Long[]>();
		return getCombos(arr, k, 0, data, 0, combos);
	}

	private static List<Long[]> getCombos(final List<Long> arr, int r, int index, long[] data, int i, List<Long[]> combos) {
		// System.out.println("index-- "+index+" i== "+i);
		int n = arr.size();

		if (index == r) {
			Long[] combo = new Long[r];
			for (int j = 0; j < r; j++) {
				combo[j] = data[j];
			}
			combos.add(combo);
			return combos;
		}

		if (i >= n) {
			return combos;
		}

		data[index] = arr.get(i);
		combos = getCombos(arr, r, index + 1, data, i + 1, combos);

		return combos = getCombos(arr, r, index, data, i + 1, combos);
	}

}
